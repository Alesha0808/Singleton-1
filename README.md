# Singleton-1
![kartinka](https://github.com/Alesha0808/Singleton-1/blob/master/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA.JPG?raw=true)

**Паттерн Одиночка направлен на создание уникальных объектов, существующих только в одном экземпляре.** Из всех паттернов Одиночка имеет самую простую диаграмму классов; собственно, вся диаграмма состоит из одного-единственного класса! Однако не стоит расслабляться; несмотря
на всю его простоту с точки зрения архитектуры классов, в его реализации кроется немало ловушек. Так что пристегните ремни!
**Программист:** И в чем польза такого паттерна?

**Гуру:** Существует много объектов, которые нужны нам только в одном экземпляре: пулы программных
потоков, кэши, диалоговые окна, объекты ведения журнала, объекты драйверов устройств... Более того, для многих типов таких объектов попытка создания более одного экземпляра приведет к всевозможным проблемам — некорректному поведению программы, лишним затратам ресурсов или нелогичным результатам.

**Программист:** Хорошо, некоторые классы действительно должны создаваться только в одном экземпляре. Но писать об этом целую главу? Разве нельзя, например, воспользоваться глобальной переменной? А в Java можно было добиться желаемого с помощью статической переменной.

**Гуру:** Паттерн Одиночка во многих отношениях представляет собой схему, которая гарантирует, что для заданного класса может быть создан один и только один объект. Если кто-нибудь придумает более удачное решение, мир о нем услышит; а пока паттерн Одиночка, как и все паттерны, представляет собой проверенный временем механизм создания единственного объекта. Кроме того, Одиночка, как и глобальная переменная, предоставляет глобальную точку доступа к данным, но без ее недостатков.

**Программист:** Каких недостатков?

**Гуру:** Простейший пример: если объект присваивается глобальной переменной, он может быть создан в начале работы приложения. Верно? А если этот объект расходует много ресурсов, но никогда не будет использоваться приложением? Как вы увидите, паттерн Одиночка позволяет создавать объекты в тот момент, когда в них появится необходимость.

**Программист:** И все равно не вижу ничего особенно сложного.

**Гуру:** Для того, кто хорошо разбирается в статических переменных и методах, а также модификаторах доступа, — ничего сложного нет. Но как бы то ни было, интересно посмотреть, как работает паттерн Одиночка, и при всей простоте его довольно непросто реализовать. Как бы вы предотвратили создание повторных экземпляров? Задача отнюдь не тривиальная, не правда ли?
# Вопросы и ответы
## Маленькое упражнение в стиле сократовских диалогов
![kartinka](https://github.com/Alesha0808/Singleton-1/blob/master/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA1.JPG?raw=true)
![kartinka](https://github.com/Alesha0808/Singleton-1/blob/master/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA2.JPG?raw=true)
## Классическая реализация паттерна Одиночка
![kartinka](https://github.com/Alesha0808/Singleton-1/blob/master/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA3.JPG?raw=true)
## Шоколадная фабрика
Всем известно, что на всех современных шоколадных фабриках используются нагреватели с компьютерным управлением. Смесь шоколада и молока в таком нагревателе доводится до кипения и передается на следующий этап изготовления шоколадных батончиков. Ниже приведен код класса, управляющего ChocO-Holic — мощным высокопроизводительным нагревателем для шоколада. Просмотрите код; вы заметите, что автор постарался сделать все возможное, чтобы избежать некоторых неприятностей — скажем, слива холодной смеси, переполнения или нагревания пустой емкости!
![kartinka](https://github.com/Alesha0808/Singleton-1/blob/master/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA5.JPG?raw=true)

### Возьми в руку карандаш
Сможете ли вы усовершенствовать класс ChocolateBoiler, преобразовав его в синглетную форму (то есть с единственным экземпляром)?
![kartinka](https://github.com/Alesha0808/Singleton-1/blob/master/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA6.JPG?raw=true)
# Определение паттерна Одиночка
**Итак, вы познакомились с классической реализацией паттерна Одиночка. Сейчас можно устроиться поудобнее, съесть шоколадку и перейти к рассмотрению некоторых нюансов паттерна Одиночка.**

**Начнем с формального определения паттерна:**
> **Паттерн Одиночка** гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру.

**Пока ничего особенного. Но давайте присмотримся повнимательнее:**
> + Что здесь по сути происходит? Мы берем существующий класс и разрешаем ему создать только один экземпляр. Кроме того, мы запрещаем любым другим классам произвольно создавать новые экземпляры этого класса. Чтобы получить экземпляр, необходимо обратиться с запросом к самому классу.
> + Кроме того, паттерн предоставляет глобальную точку доступа к экземпляру: обратившись с запросом к классу в любой точке программы, вы получите ссылку на единственный экземпляр. Как было показано выше, возможно отложенное создание экземпляра, что особенно важно для объектов, создание которых сопряжено с большими затратами ресурсов.

**Обратимся к диаграмме классов:**

![kartinka](https://github.com/Alesha0808/Singleton-1/blob/master/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA7.JPG?raw=true)

 ## Кажется, у нас проблемы...
**Похоже, программа управления нагревателем нас подвела; хотя мы усовершенствовали код и перешли на классическую реализацию паттерна Одиночка, метод fill() класса ChocolateBoiler почему-то начал заполнять емкость, которая уже была заполнена! 500 галлонов молока (и шоколада) пролилось на пол. Что произошло?!**

![kartinka](https://github.com/Alesha0808/Singleton-1/blob/master/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA8.JPG?raw=true)

**Могло ли введение программных потоков привести к катастрофе? Ведь после того, как переменной uniqueInstance будет присвоен единственный экземпляр ChocolateBoiler, все вызовы getInstance() должны возвращать один и тот же экземпляр? Разве нет?**

![kartinka](https://github.com/Alesha0808/Singleton-1/blob/master/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA9.JPG?raw=true)

## Решение проблемы многопоточного доступа

**Наши многопоточные проблемы решаются почти тривиально: метод getInstance()
объявляется синхронизированным:**

![kartinka](https://github.com/Alesha0808/Singleton-1/blob/master/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA10.JPG?raw=true)

В точку! На самом деле ситуация еще серьезнее: синхронизация актуальна только при первом вызове этого метода. Иначе говоря, после того, как переменной uniqueInstance будет присвоен экземпляр синглетного класса, необходимость в дальнейшей синхронизации этого метода отпадает. После первого выполнения синхронизация только приводит к лишним затратам ресурсов!

## Можно ли усовершенствовать многопоточную реализацию?
Безусловно, в большинстве Java-приложений мы должны позаботиться о том, чтобы паттерн работал в многопоточном коде. Но синхронизация метода getInstance() приводит к значительным затратам ресурсов. Что же делать?

Есть несколько вариантов.
**1. Ничего не делать, если производительность getInstance() не критична
для вашего приложения**

Да, вы не ошиблись: если вызов getInstance() не приводит к заметному ухудшению быстродействия, не обращайте внимания. Синхронизация getInstance() — простое и эффективное решение. Только помните, что синхронизация метода может замедлить его выполнение в сто и более раз. Если метод getInstance() применяется в интенсивно используемой
части приложения, возможно, вам стоит пересмотреть свое решение.

**2. Создавайте экземпляр заранее**

Если приложение всегда создает и использует экземпляр синглетного класса или затраты за создание не столь существенны, экземпляр можно создать заранее:

![kartinka](https://github.com/Alesha0808/Singleton-1/blob/master/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA11.JPG?raw=true)

При таком подходе мы доверяем JVM создание уникального экземпляра Singleton при загрузке класса. JVM гарантирует, что экземпляр будет создан до того, как какой-либо поток сможет обратиться к статической переменной uniqueInstance. 

**3. Воспользуйтесь «условной блокировкой», чтобы свести к минимуму использование
синхронизации в getInstance()**

Сначала проверьте, создается ли новый экземпляр, и если нет — ТОГДА синхронизируйте фрагмент кода. В этом случае синхронизация будет выполняться только при первом вызове (что нам, собственно, и требовалось).

Давайте проверим код:

![kartinka](https://github.com/Alesha0808/Singleton-1/blob/master/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA12.JPG?raw=true)

Если производительность выполнения getInstance() критична, то этот способ реализации кардинально ускорит выполнение метода.

## Тем временем на шоколадной фабрике...

Пока мы разбирались с проблемами многопоточности, нагреватель уже почистили, и он снова готов к работе. Но сначала необходимо исправить допущенную ошибку. Имеется несколько решений, каждое из которых обладает своими достоинствами и недостатками; какое из них следует применить?

![kartinka](https://github.com/Alesha0808/Singleton-1/blob/master/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA13.JPG?raw=true)
